---
output:
  pdf_document: 
    fig_width: 6
    fig_height: 4
  html_document: default
editor_options: 
  chunk_output_type: console
---

# Course Practical Assignment - 3rd Deliverable (maig del 2019)
## *Josep Clotet Ginovart*
## *Eric Martin Obispo*

# Bank client data
## Description of input variables:

  1. age (numeric)
  2. job : type of job (categorical: 'admin', 'blue-collar', 'entrepreneur', 'housemaid', 'management', 'retired', 'self-employed', 'services', 'student', 'technician', 'unemployed', 'unknown')
  3. marital : marital status (categorical: 'divorced','married','single','unknown'; note: 'divorced' means divorced or widowed)
  4. education (categorical:'basic.4y', 'basic.6y', 'basic.9y', 'high.school', 'illiterate', 'professional.course', 'university.degree', 'unknown')
  5. default: has credit in default? (categorical: 'no','yes','unknown')
  6. housing: has housing loan? (categorical: 'no','yes','unknown')
  7. loan: has personal loan? (categorical: 'no','yes','unknown')# related with the last contact of the current campaign:
  8. contact: contact communication type (categorical:'cellular','telephone')
  9. month: last contact month of year (categorical: 'jan', 'feb', 'mar',..., 'nov', 'dec')
  10. day_of_week: last contact day of the week (categorical:'mon','tue','wed','thu','fri')
  11. duration: last contact duration, in seconds (numeric). Important note: this attribute highly affects the output target (e.g., if duration=0 then y='no'). Yet, the duration is not known before a call is performed. Also, after the end of the call y is obviously known. Thus, this input should only be included for benchmark purposes and should be discarded if the intention is to have a realistic predictive model.
  12. campaign: number of contacts performed during this campaign and for this client (numeric, includes last contact)
  13. pdays: number of days that passed by after the client was last contacted from a previous campaign (numeric; 999 means client was not previously contacted)
  14. previous: number of contacts performed before this campaign and for this client (numeric)
  15. poutcome: outcome of the previous marketing campaign (categorical: 'failure','nonexistent','success')# social and economic context attributes
  16. emp.var.rate: employment variation rate - quarterly indicator (numeric)
  17. cons.price.idx: consumer price index - monthly indicator (numeric)
  18. cons.conf.idx: consumer confidence index - monthly indicator (numeric)
  19. euribor3m: euribor 3 month rate - daily indicator (numeric)
  20. nr.employed: number of employees - quarterly indicator (numeric)
  21. y - has the client subscribed a term deposit? (binary: 'yes','no')

# Loading packages:
```{r, include=FALSE}
# Required Packages: to be increased over the course
requiredPackages <- c("car","knitr","ggplot2","FactoMineR","missMDA","mvoutlier","chemometrics", "factoextra", "MASS", "effects")
missingPackages <- requiredPackages[!(requiredPackages %in% installed.packages()[,"Package"])]

if(length(missingPackages)) install.packages(missingPackages)
lapply(requiredPackages, require, character.only = TRUE)

```

# Load validated data from Deliverable 1:
```{r}
#dirwd<-"D:/Users/Usuari/Documents/ADEIpractica"
#dirwd<-"//pax/perfils/1173408.CR/Downloads/deliverable"
dirwd<-"D:/Documents/GitHub/ADEI"
setwd(dirwd)

load( paste0(dirwd, "/bank-additional/Bank5000_validated.RData") )
summary(df)
```

# Variables numeriques explicatives
Per tal d'elaborar un model lineal que predigui el valor de la variable numerica target *duration*, primer hem de decidir quines son les variables (columnes) que utilitzarem en la seva cosntruccio. En altres paraules, trobar quines variables ens aproten informacio i precisio al model predictiu, pero sense sobreparametritzar-lo. 

## Model inicial amb totes les variables numeriques
Una primera (i dolenta) aproximacio podria ser la d'usar un model lineal inicial que tingui en compte totes les variables numeriques aportades. Veiem com aquestes variables en un model lineal nomes ens expliquen l' 1.3% de la variabilitat de l'output *duration* (Multiple R-squared: 0.01309)! El que vol dir que gairebé un 99% d'questa variabilitat de la duracio queda sense explicar, el que vol dir que aquesta primera aproximacio, a part d'estar sobreparametritzada, no prediu gens be.
```{r}
vars_con
#li treiem la variable target a la llista de variables numeriques explicatives
vars_exp<-c(vars_con[1], vars_con[3:10]); vars_exp

m1<-lm(duration~., data=df[,vars_con]) #es passa nomes el df amb les variables continues perque li hem posat un '.' al model que vol dir que les agafi totes, i ara nomes volem variables explciatives numeriques; si especificiquem les variables numeriques explicatives del model i volem que el calculi per tot el df incloent variables categoriques, "data" el passem com =df.
summary(m1)
```


## Model inicial amb nomes les variables numeriques rellevants
Una altra opcio mes adient seria la d'obtenir un model inicial utilitzant nomes les variables numeriques que son rellevants, i a partir d'aqui mirar si es pot reduir la parametritzacio del model i seguir amb un bon ajust predictiu de la variabilitat del nostre output *duration*. Per a trobar les variables rellevants, podem realitzar tests de Fisher mitjancant la comanda Anova d'R, o be utilitzar la comanda condes vista en anteriors entregues.

### Inferential criteria o Bayesian info criteria
Utilitzem la comanda Anova per a realitzar tests de Fisher i detectar i eliminar variables poc explicatives en els models.

El test Anova ens diu linia a linia si cada variable es significativa a l'hora d'aportar informacio en el model. Cada fila es refereix a un test de models encaixats del model m1 amb el model m1 sense la variable expressada en la fila.Per tant, si el p-valor es <0.05 podem refutar la H0 que deia que els models eren iguals. La podem refutar amb les variables age i indicadors socioeconomics, que vol dir que no ens aporten informacio extra al model. En canvi, per les variables campaign, pdays, previous i emp.var.rate, no podem refutar la H0, el que vol dir que si que ens estan aportant informacio al model i no les podem eliminar. Podriem contemplar tambe quedar-nos amb nr.employed, ja que esta prop de la frontera del p-valor teoric vs la flexibilitat a la practica. El model m2 es el model obtingut amb aquestes variables rellevants.
```{r}
#METODE TESTS FISHER:
#remove non significant variables, per a saber quines son fem tests de Fisher amb la comanda Anova d'R
Anova(m1)

m2<-lm(duration~campaign+pdays+previous+emp.var.rate+nr.employed, data=df)
Anova(m2)
```

Un altre metode pas a pas es el metode Akaike. Va eliminant en models successius les variables que treient-les, obtindriem un AIC mes baix, ja que ens interessa un coeficient d'Akaike que quan no li treiem cap variable es mantingui igual. Un trade-off entre el fitting del model i la sobre parametritzacio. El model m3 *duration ~ campaign + pdays + previous + emp.var.rate + cons.conf.idx + nr.employed* es el model obtingut amb aquest metode.
```{r}
#AKAIKE:
m3<-step(m1)
```

Hi ha un altre metode anomenat Bayesian, el qual es millor per a mostres grans com la nostra, ja que tot i funcionar com l'anterior, solen sortir models mes simplificats. El model m4 *duration ~ campaign + emp.var.rate + nr.employed* es el model obtingut amb aquest metode.
```{r}
#BAYESIAN (BIC):
m4<-step(m1, k=log(nrow(df)))
summary(m4)
```


### Condes per a obtenir les variables numeriques rellevants
Utilitzant la comanda condes vista en anteriors entregues tambe podem trobar les variables que son rellevants pel nostre model. El model que obtenim aixi es el m5, i la comanda Anova ens diu que pdays no esta aportant res de nou (p-value=0.32). La treiem i ens queda el model m6, que correspon a *duration ~ euribor3m + nr.employed + campaign*.
Si apliquem un metode BIC en aquest model obtenim un model m7 amb nomes un sol parametre aportant informacio que es campaign. Aquest model es massa simple i no ens va be per a treballar, aixi que ens quedem amb el model m4 obtingut anterirment tambe pel metode Bayesian.
```{r}
condes(df, 11) #variable target: 11 (duration)

#Agafem com a variables explicatives les $quanti del condes:
m5<-lm(duration~pdays+euribor3m+nr.employed+campaign, data=df); Anova(m5)
m6<-lm(duration~euribor3m+nr.employed+campaign, data=df); Anova(m6) #totes les variables ens aporten informacio nova

#BIC
m7<-step(m6, k=log(nrow(df)))
```

La comanda vif d'R ens diu les variables utilitzades en el model tenen redundancies. Si el seu valor esta per sota de 3 es valid; i si dos valors son iguals vol dir que d'aquelles dues variables ens n'em de quedar nomes una! En el cas del model m4 ens quedarem amb la variable campaign i nr.employed (triada d'entre les dues amb valor similar).
```{r}
vif(m4)
m44<-lm(duration~campaign+nr.employed, data=df); Anova(m44)
```


## Plots del model m4
```{r}
par(mfrow=c(2,2))
plot(m4) #models forca dolents
par(mfrow=c(1,1))

residualPlots(m4)
marginalModelPlots(m4)
influencePlot(m4)
```


## Transformacio la variable target numerica
A vegades una transformacio de la variable target numerica pot millorar el model. La comanda Bo-Cox ens mostra com el valor de lambda estimat es proper a 0, vol dir que hem d'elevar a 0 el target, com que aixo no es pot fer, la transformacio estadistica del nostre target sera el logaritme, i la farem a partir del model m5 obtingut anteriorment (aixi donarem marge a possibles reduccions del mateix).
FALTARIA COMPARAR MODELS ENCAIXATS! altre .rmd!?
```{r}
#Box-Cox
boxcox(m5, data=df)

#TRANSFORMACIO LOGARITMICA Y(m5) -> logY
m8<-lm(log(duration)~pdays+euribor3m+nr.employed+campaign, data=df); Anova(m8)

#BIC
m10<-step(m8, k=log(nrow(df))); vif(m10) #euribor3m i employed mostren molta colinearitat, ens quedem amb euribor3m
m11<-lm(log(duration)~euribor3m+campaign, data=df); vif(m11)
summary(m11)

#POLINOMIC REGRESSION
#com hi ha poques variables provem de transformar-les totes amb regressio polinomica
m20<-lm(log(duration)~poly(euribor3m, 2)+poly(campaign, 2), data=df)
summary(m20); Anova(m20) #veiem com amb ambdos termes quadratics(2) tenen un p-value <0.05. Es millor que el terme lineal(1) en el cas d l'euribor3, podriem fer per tant aquesta transformacio quadratica.

par(mfrow=c(2,2))
plot(m20)
par(mfrow=c(1,1))

```


# Variables discretes explicatives
Mitjancant la comanda condes intentarem trobar variables discretes que estiguin relacionades amb la variable target numerica duration. D'aquesta manera sabrem quines variables discretes podem utilitzar en el model predictiu per a que ens aportin informacio. 
A partir del millor model anterior de variables continues, hem d'obtenir un nou model afegint les variables discretes i factoritzades (no a partir d'una que ja estava al model). En el nostre cas agafem campaign i nr.employed com a variabels continues, i afegim f.cons.conf.idx+f.cons.price.idx+month+f.euribor3m+poutcome com a variables discretes.
```{r}
condes(df[, c("duration", vars_dis)], 1, proba=0.01)

#campaign+nr.employed son continues, del millor model anterior amb vairables continues
m60<-lm(log(duration)~campaign+nr.employed+f.cons.conf.idx+f.cons.price.idx+month+f.euribor3m+poutcome, data=df)
summary(m60)
Anova(m60)
```

Si el condes anterior ens ha donat com a variables factor significatives algunes que ja teniem en el model com a continues, hem de triar o una o altra versio. Si tenim dubtes entre agafar una variable com a continua o factoritzada, hem de fer el següent:
Veiem com en ambdues variables obtenim que es millor usar la seva versio numerica (no factoritzada).
```{r}
#per campaign, mateix model pero amb f.campaign enlloc de campaign:
maux<-lm(log(duration)~f.campaign+nr.employed+f.cons.conf.idx+f.cons.price.idx+month+f.euribor3m+poutcome, data=df)

#com que m60 i maux no son anidats, no els modem comparar amb un test de Fisher --> BIC
BIC(m60, maux) #choose option with minimum BIC -> better
#      df      BIC
# m60  24 13143.82  --> millor model amb campaign com a numerica
# maux 25 13199.11

maux<-lm(log(duration)~campaign+f.nr.employed+f.cons.conf.idx+f.cons.price.idx+month+f.euribor3m+poutcome, data=df)
BIC(m60, maux)
#      df      BIC
# m60  24 13143.82  --> millor model amb nr.employed com a numerica
# maux 25 13151.61

#si haguessim hagut de fer el mateix amb pdays, ojo!!!! pq la continua ha estat majoritariament imputada, per tant en aquest cas, tot i el test, hauriem d'agafar la factoritzada!
```

Mirem si podem simplificar el model eliminant variables poc significatives mitjancant la comanda step i veiem com ens podem quedar amb les variables numeriques nr.employed i campaign, i la variable factor f.cons.price.idx.
Si ho fem mitjancant la comanda Anova, veiem com ens surt el mateix resultat pero agafant tambe la variable discreta poutcome. Aixi doncs tambe li farem cas i aquest model sera el m62, que explica el 5% (R^2=0.04959) de la variabilitat de l'output del logaritme de *duration*.
```{r}
m61<-step(m60, k=log(nrow(df)))

Anova(m60)
m62<-lm(log(duration)~campaign+nr.employed+f.cons.price.idx+poutcome, data=df); summary(m62)
```


```{r}
summary(df[, c("campaign", "nr.employed", "f.cons.price.idx", "poutcome")])
model.matrix(m62)
```


# Interactions
Partint del model anterior, li afegim interaccions 2 a 2 entre totes les seves variables, simplifiquem i veiem com hi ha dues interaccions significatives: campaign:nr.employed i campaign:f.cons.price.idx. Nomes podem tenir en compte en el nostre model pero, interaccions entre factors o entre factor i variable numerica, aixi que amb el tests d'Anova mirarem manualment quines interaccions valides ens quedem, el que ens porta a un model m73.
```{r}
#interaccio entre 2 variables:
m70<-lm(log(duration)~(campaign+nr.employed+f.cons.price.idx+poutcome)^2, data=df)
summary(m70);coef(m70)
m71<-step(m70, k=log(nrow(df))); Anova(m71) #el criteri Anova(fisher) reafirma el step(BIC) en aquest cas :)!
# log(duration) ~ campaign + nr.employed + f.cons.price.idx + campaign:nr.employed + campaign:f.cons.price.idx
# 
#                             Df Sum of Sq    RSS     AIC
# <none>                                   3907.1 -1130.7
# - campaign:nr.employed       1    13.192 3920.3 -1122.4
# - campaign:f.cons.price.idx  3    30.057 3937.1 -1118.0
anova(m71, m70) #Pr(>F) = 0.03967 *  --> els models no son equivalents


Anova(m70)
#                              Sum Sq   Df  F value    Pr(>F)    
# campaign                      139.1    1 177.5733 < 2.2e-16 ***
# nr.employed                     4.9    1   6.2304  0.012590 *  
# f.cons.price.idx               31.3    3  13.3261 1.162e-08 ***
# poutcome                        8.9    2   5.7067  0.003345 ** 
# campaign:nr.employed            7.7    1   9.8365  0.001721 **  --> entre dos numeriques
# campaign:f.cons.price.idx      25.3    3  10.7841 4.635e-07 *** --> entre numerica i factor --> agafem
# campaign:poutcome               0.2    2   0.1354  0.873389     --> entre numerica i factor
# nr.employed:f.cons.price.idx    5.8    3   2.4861  0.058763 .   --> entre numerica i factor
# nr.employed:poutcome            1.8    2   1.1741  0.309191     --> entre numerica i factor
# f.cons.price.idx:poutcome       7.9    6   1.6823  0.121019     --> entre factors --> agafem aquest per l'entrega

m73<-lm(log(duration)~campaign+nr.employed+f.cons.price.idx+poutcome+campaign:f.cons.price.idx+f.cons.price.idx:poutcome, data=df)
anova(m73, m70) #Pr(>F) = 0.003286 **  --> els models no son equivalents

```

## Interaction between a couple of factors
```{r}
#f.cons.price.idx:poutcome
m80<-lm(log(duration)~f.cons.price.idx+poutcome, data=df); summary(m80)

scatterplot(log(duration)~f.cons.price.idx|poutcome, data=df)

```

## Interaction between factor and covariate
```{r}
#campaign|f.cons.price

#model petit sense interaccions
m85<-lm(log(duration)~campaign+f.cons.price.idx, data=df); summary(m85)
scatterplot(log(duration)~campaign|f.cons.price.idx, data=df) #Suport visual
plot(allEffects(m85)) #effects library

#model gran amb interaccions: 3 parametres-> campaign, f.cons.price.idx, campaign:f.cons.price.idx
m855<-lm(log(duration)~campaign*f.cons.price.idx, data=df); summary(m855) 
#are interactions significant?
anova(m85, m855) #Pr(>F)  5.152e-05 ***  --> H0 rejected --> m855 X*A 
plot(allEffects(m855))



#campaign|poutcome --> segons el test anterior, la interaccio no ha sortit gaire significativa, pero s'interpreta millor visualment
m86<-lm(log(duration)~campaign+poutcome, data=df); summary(m85)
scatterplot(log(duration)~campaign|poutcome, data=df)
plot(allEffects(m86))

m866<-lm(log(duration)~campaign*poutcome, data=df); summary(m866) 
anova(m86, m866) #Pr(>F)  0.1435  --> H0 accepted --> els models son iguals, per tant no cal el model gran amb interaccions 
```



